#!/usr/bin/env bash
set -euo pipefail

cd "$(dirname "$0")/.."

# ensure bun/cargo are in PATH
[[ -f "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env"
export PATH="${HOME}/.bun/bin:$PATH"

usage() {
  cat <<EOF
usage: ./bin/dev [--browser | --desktop]

  --browser   vite dev server + gatekeeper (default)
  --desktop   cargo tauri dev (spawns gatekeeper from rust)
EOF
  exit 1
}

mode="browser"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --browser)  mode="browser"; shift ;;
    --desktop)  mode="desktop"; shift ;;
    -h|--help)  usage ;;
    *)          echo "unknown flag: $1" >&2; usage ;;
  esac
done

# ---------------------------------------------------------------------------
#  Gatekeeper supervisor — auto-respawn with exponential backoff
# ---------------------------------------------------------------------------
SHUTTING_DOWN=false
gk_pid=""
vite_pid=""

GK_MAX_BACKOFF=16   # max seconds between respawn attempts
GK_INITIAL_BACKOFF=1

start_gatekeeper() {
  # kill any orphaned gatekeeper on port 3001 before starting
  lsof -ti:3001 2>/dev/null | xargs kill -9 2>/dev/null || true
  sleep 0.2

  bun run gatekeeper/src/index.ts &
  gk_pid=$!
}

wait_for_gatekeeper() {
  for _i in $(seq 1 20); do
    curl -sf http://localhost:3001/health >/dev/null 2>&1 && return 0
    sleep 0.25
  done
  return 1
}

# Supervisor loop: runs in background, restarts gatekeeper on unexpected exit
supervise_gatekeeper() {
  local backoff=$GK_INITIAL_BACKOFF

  while true; do
    # wait for the current gatekeeper process to exit
    local exit_code=0
    wait "$gk_pid" 2>/dev/null || exit_code=$?

    # if we're shutting down, don't respawn
    if $SHUTTING_DOWN; then
      return
    fi

    echo ""
    echo "  !! gatekeeper (pid $gk_pid) exited with code $exit_code — respawning in ${backoff}s..."
    sleep "$backoff"

    # double backoff up to max
    if [[ $backoff -lt $GK_MAX_BACKOFF ]]; then
      backoff=$((backoff * 2))
      if [[ $backoff -gt $GK_MAX_BACKOFF ]]; then
        backoff=$GK_MAX_BACKOFF
      fi
    fi

    if $SHUTTING_DOWN; then
      return
    fi

    echo "  ==> respawning gatekeeper"
    start_gatekeeper

    if wait_for_gatekeeper; then
      echo "  gatekeeper back up (pid $gk_pid)"
      backoff=$GK_INITIAL_BACKOFF  # reset backoff on successful start
    else
      echo "  WARNING: gatekeeper not responding after respawn"
    fi
  done
}

kill_pid() {
  local pid="$1"
  [[ -z "$pid" ]] && return

  # SIGTERM
  kill "$pid" 2>/dev/null || true

  # wait up to 2 seconds
  local deadline=$((SECONDS + 2))
  while kill -0 "$pid" 2>/dev/null; do
    if [[ $SECONDS -ge $deadline ]]; then
      break
    fi
    sleep 0.1
  done

  # SIGKILL if still alive
  kill -9 "$pid" 2>/dev/null || true
}

cleanup() {
  SHUTTING_DOWN=true
  echo ""
  echo "shutting down..."

  # ask gatekeeper to shut down gracefully via HTTP first
  curl -sf -X POST http://localhost:3001/control/shutdown >/dev/null 2>&1 || true

  kill_pid "$gk_pid"
  kill_pid "$vite_pid"
  wait 2>/dev/null || true

  # kill any orphaned gatekeeper on port 3001
  lsof -ti:3001 2>/dev/null | xargs kill -9 2>/dev/null || true

  echo "done."
}

if [[ "$mode" == "browser" ]]; then
  trap cleanup EXIT INT TERM

  echo "==> starting gatekeeper on :3001"
  start_gatekeeper

  if wait_for_gatekeeper; then
    echo "  gatekeeper ready (pid $gk_pid)"
  else
    echo "  WARNING: gatekeeper not responding on :3001"
  fi

  echo "==> starting vite on :1420"
  bun run dev &
  vite_pid=$!

  echo ""
  echo "  browser: http://localhost:1420"
  echo "  gatekeeper: http://localhost:3001"
  echo "  (gatekeeper auto-respawns on crash)"
  echo ""

  # supervisor loop runs in foreground — keeps the script alive
  supervise_gatekeeper
else
  echo "==> cargo tauri dev"
  echo "  (gatekeeper is spawned by the rust backend)"
  echo ""
  cargo tauri dev
fi
