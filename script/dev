#!/usr/bin/env bun

import { $ } from "bun";
import { spawn, type Subprocess } from "bun";
import { resolve } from "node:path";

const ROOT = resolve(import.meta.dir, "..");
process.chdir(ROOT);

// ---------------------------------------------------------------------------
//  CLI
// ---------------------------------------------------------------------------
const args = process.argv.slice(2);
let mode: "browser" | "desktop" = "browser";

for (const arg of args) {
  if (arg === "--browser") mode = "browser";
  else if (arg === "--desktop") mode = "desktop";
  else if (arg === "-h" || arg === "--help") {
    console.log(`usage: ./script/dev [--browser | --desktop]

  --browser   vite dev server + gatekeeper (default)
  --desktop   cargo tauri dev (spawns gatekeeper from rust)`);
    process.exit(0);
  } else {
    console.error(`unknown flag: ${arg}`);
    process.exit(1);
  }
}

// ---------------------------------------------------------------------------
//  Helpers
// ---------------------------------------------------------------------------
const GK_PORT = 3001;
const GK_URL = `http://localhost:${GK_PORT}`;
const MAX_BACKOFF = 16;
const INITIAL_BACKOFF = 1;

let shutting_down = false;
let gk_proc: Subprocess | null = null;
let vite_proc: Subprocess | null = null;

function sleep(seconds: number): Promise<void> {
  return new Promise((r) => setTimeout(r, seconds * 1000));
}

async function health_check(): Promise<boolean> {
  try {
    const res = await fetch(`${GK_URL}/health`);
    return res.ok;
  } catch {
    return false;
  }
}

async function wait_for_gatekeeper(): Promise<boolean> {
  for (let i = 0; i < 20; i++) {
    if (await health_check()) return true;
    await sleep(0.25);
  }
  return false;
}

async function kill_port(port: number): Promise<void> {
  try {
    await $`lsof -ti:${port}`.quiet().text().then((pids) => {
      for (const pid of pids.trim().split("\n").filter(Boolean)) {
        try { process.kill(Number(pid), "SIGKILL"); } catch {}
      }
    });
  } catch {}
}

function kill_proc(proc: Subprocess | null): void {
  if (!proc || proc.exitCode !== null) return;
  try { proc.kill("SIGTERM"); } catch {}
}

function force_kill_proc(proc: Subprocess | null): void {
  if (!proc || proc.exitCode !== null) return;
  try { proc.kill("SIGKILL"); } catch {}
}

function start_gatekeeper(): Subprocess {
  return spawn({
    cmd: ["bun", "run", "gatekeeper/src/index.ts"],
    cwd: ROOT,
    stdout: "inherit",
    stderr: "inherit",
  });
}

// ---------------------------------------------------------------------------
//  Cleanup
// ---------------------------------------------------------------------------
async function cleanup() {
  if (shutting_down) return;
  shutting_down = true;
  console.log("\nshutting down...");

  // graceful HTTP shutdown
  try {
    await fetch(`${GK_URL}/control/shutdown`, { method: "POST" });
  } catch {}

  // SIGTERM both
  kill_proc(gk_proc);
  kill_proc(vite_proc);

  // give 2 seconds to exit
  await sleep(2);

  // SIGKILL stragglers
  force_kill_proc(gk_proc);
  force_kill_proc(vite_proc);

  // orphan cleanup
  await kill_port(GK_PORT);

  console.log("done.");
  process.exit(0);
}

process.on("SIGTERM", cleanup);
process.on("SIGINT", cleanup);

// ---------------------------------------------------------------------------
//  Desktop mode
// ---------------------------------------------------------------------------
if (mode === "desktop") {
  console.log("==> cargo tauri dev");
  console.log("  (gatekeeper is spawned by the rust backend)\n");
  const tauri = spawn({
    cmd: ["cargo", "tauri", "dev"],
    cwd: ROOT,
    stdout: "inherit",
    stderr: "inherit",
  });
  process.exitCode = await tauri.exited;
  process.exit();
}

// ---------------------------------------------------------------------------
//  Browser mode — gatekeeper supervisor + vite
// ---------------------------------------------------------------------------
await kill_port(GK_PORT);
await sleep(0.2);

console.log("==> starting gatekeeper on :3001");
gk_proc = start_gatekeeper();

if (await wait_for_gatekeeper()) {
  console.log(`  gatekeeper ready (pid ${gk_proc.pid})`);
} else {
  console.log("  WARNING: gatekeeper not responding on :3001");
}

console.log("==> starting vite on :1420");
vite_proc = spawn({
  cmd: ["bun", "run", "dev"],
  cwd: ROOT,
  stdout: "inherit",
  stderr: "inherit",
});

console.log(`
  browser:    http://localhost:1420
  gatekeeper: http://localhost:3001
  (gatekeeper auto-respawns on crash)
`);

// ---------------------------------------------------------------------------
//  Supervisor loop
// ---------------------------------------------------------------------------
let backoff = INITIAL_BACKOFF;

while (!shutting_down) {
  const exit_code = await gk_proc.exited;

  if (shutting_down) break;

  console.log(
    `\n  !! gatekeeper (pid ${gk_proc.pid}) exited with code ${exit_code} — respawning in ${backoff}s...`,
  );
  await sleep(backoff);

  // exponential backoff, cap at MAX_BACKOFF
  backoff = Math.min(backoff * 2, MAX_BACKOFF);

  if (shutting_down) break;

  console.log("  ==> respawning gatekeeper");
  await kill_port(GK_PORT);
  await sleep(0.2);
  gk_proc = start_gatekeeper();

  if (await wait_for_gatekeeper()) {
    console.log(`  gatekeeper back up (pid ${gk_proc.pid})`);
    backoff = INITIAL_BACKOFF;
  } else {
    console.log("  WARNING: gatekeeper not responding after respawn");
  }
}
